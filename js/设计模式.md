# 设计模式

## 设计模式是什么
    设计模式就是最佳实践，是多年来被反复使用，对反复出现的问题的代码设计经验的总结

## 设计模式的原则

    设计模式的原则一般有以下6种
        1. 单一职责原则
            描述
                每个模块都有且只有一个需要被改变的理由，引起变化的原因就是职责
            
            好处
                可以降低模块的复杂度，控制颗粒度、提高内聚性，减少功能更改引起的关联风险，
                提高代码的可读性和可维护性

        2. 开放封闭原则
            描述
                系统应该对扩展开放，对修改关闭
                如果软件系统想要更容易被改变，那么设计就必须允许新增代码来修改系统行为，
                而不是只能靠修改原来的代码
            
            好处
                增加了项目的灵活性


        3. 里斯科夫替代原则
            描述
                一个子类应该可以替换掉父类并且可以正常工作
            
            好处
                增强了程序的健壮性，降低了出错的可能性

        
        4. 接口隔离原则
            描述
                一个类对另一个类的依赖应该建立在最小的接口上
            
            好处
                提高系统灵活性和可维护性，降低耦合性，提高内聚性，减少代码的冗余
            
            注意
                单一职责原则针对的是程序的实现和细节，接口隔离原则主要是针对抽象和框架的构建

        5. 依赖反转原则
            描述
                高层代码不应该依赖底层代码，相反低层代码应当依赖高层代码

            好处
                并行开发更加的友好

        6. 迪米特法则

            描述
                减少模块之间的联系
            
            
            好处
                提高模块的独立性，降低耦合度
            

## 单例模式

### 定义

    保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 好处

    减少性能开销
    

### 适用场景

    重复实例化一个类，但是可以使用相同实例代替的
    
    数据的缓存，例如开销较大的纯函数

    确保全局唯一对象

    利用单例进行对象克隆

### 实现

    单例模式的实现很简单，只需要通过一个变量来判断是否已创建，为防止这个变量被误改，
    可以放入函数闭包中
    JavaScript的对象可以直接使用字面量声明，不一定需要通过new关键字

```JavaScript
    const {log} = console;

    const create = (function (){
        let obj;

        return function(){
            if(!obj){
                obj = {name:'single'};
            }
            return obj;
        }
    })();

    let s1 = create(),
        s2 = create();

    log(s1===s2); // true
```

### 透明单例

    所谓的透明单例就是使用方式跟平常使用new class一样，感受不到区别就是透明

### 代理实现单例模式

    利用代理实现单例，可以分离单例和实例的类，是程序变得更加灵活

```JavaScript
    class A{
        constructor(){
            console.log('instance A');
        }
    }

    const  ProxyA = (function(){
        let instance = null;

        return class{
            constructor(){
                if(!instance){
                    instance = new A;
                }
                return instance;
            }
        
        }
        
    })();

    new ProxyA, // instance A
    new ProxyA;

```

    这里还可以进一步分类，因为这里ProxyA还是具有单例和实例化A的职责，
    可以将实例化A泛化成实例化某个类

```JavaScript
    class A {
        constructor() {
            console.log('instance A');
        }
    }

    const createSingle = function (target) {
        let instance = null;

        return function(){
         return  instance || (instance = new target);
        }
    }

    const ProxyA = createSingle(A);

    new ProxyA, // instance A
        new ProxyA;

```

### 最佳实践

    1. 如果单例需要全局使用，可以存放到自定义的命名空间内，减少全局污染
    2. 如果单例并非是一定会使用的，可以惰性化，等到使用时再去实例化

<br/>

## 策略模式

### 定义

    定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换

### 使用

    在JavaScript中可以相互替换意味着具有相同的意图和目标
    所有的设计模式都有一个共同的主题，将动态和静态的代码分离
    一个策略模式由两部分组成，一个是策略，负责计算，另一个是环境，根据环境使用对应的策略


    下面一个在JavaScript中的一个策略模式示例

```JavaScript
    // 不同交通工具的的时间计算策略
    const strategy = {
        step:function(distance){
            return distance*10;
        },

        bike:function(){
            return distance*3;
        },

        car:function(){
            return distance;
        }
    }

    /**
     * 
     * @param {String} type 交通工具类型
     * @param {Number} distance 公里数
     * @returns 
     */
    function getTime(type,distance){
        return strategy[type](distance);
    }

```

    在上面代码中getTime就是环境，会根据接收的数据去使用对用的计算策略

### 优缺点

    优点
        1. 可有有效避免大量的条件语句
        2. 将策略单独封装，便于扩展
        3. 策略具有可复用性，可以减少重复代码
   
    缺点
        需要了解各个策略的特点，才能选择合适的策略

   

## 代理模式

### 描述
    代理模式是一种结构型设计模式，用来提供对象的替代品或占位符，
    代理控制着对原对象的访问，并且可以在访问对象前后进行操作

### 保护代理

    保护代理一般用来过滤对原对象的请求

```JavaScript

    const A = {
        eat(food){
            log(`I like ${food}`);
        }
    }

    const proxyA = {
        receive(food){
            if(['大蒜','葱'].includes(food)) return;

            A.eat(food);
        }
    }

    proxyA.receive('牛肉'), // I like 牛肉
    proxyA.receive('葱');
```

### 虚拟代理

    虚拟代理用来在真正对象创建前作为替身，在真正的对象创建完之后再将请求转发给它


### 虚拟代理的适用场景

    某些短时间内会产生大量HTTP请求场景

    真正对象开销较大或加载时间较长的的场景


### 缓存代理

    缓存一些开销较大的运算结果，避免相同参数重复执行

### 优点

    可以在客户端毫无察觉的情况下控制服务对象
    即使服务对象未准备好，代理依然可以工作
    开闭原则，可以在不修改服务对象和客户端的情况下添加新代理

### 缺点

    代码可能会变复杂
    服务器响应可能会延迟


<br/>

## 迭代器模式


### 描述
    
    迭代器模式可以在不需要暴露底层结构的情况下，
    提供一种方法顺序访问一个聚合对象中的各个元素
    

### 内部迭代器

    内部迭代器需要提供一个回调函数，在内部迭代执行，不会对外暴露当前迭代的值，只会返回一个最终结果

    可以减少重复代码，统一处理数据


### 外部迭代器

    外部迭代器每次迭代的值都可以在外部获取到

    可以根据迭代的值来决定是否终止迭代

### 适合场景
    当集合内部是非常复杂的数据结构时，可以对客户端隐藏复杂性
    减少程序中重复的遍历代码
    想要遍历不同的以及不确定的结构时可以使用迭代器模式


<br/>

## 发布-订阅模式

### 描述
    发布订阅模式也叫做观察者模式，他用来定义对象之间一对多的依赖关系，
    当一个对象的状态发生变化，所有依赖他的对象都将得到通知

### 观察者与发布订阅的区别

    发布订阅模式
        
        发布订阅模式解耦了发布者与订阅者的关系，
        发布者会将事件发布到事件中心，
        订阅者订阅的是事件而非发布者，
        发布者发布事件到队列中，
        订阅者可以是被通知的，
        也可以是定时主动去获取，进行批量处理

        优点
            灵活

        缺点
            太过灵活代码也维护难度也会增加

            需要维护一个事件队列消耗内存


    观察者模式
        观察者模式中多个观察者直接监听目标对象，
        当目标对象发生改变，会直接通知所有观察者

        优点
            目标变化会直接通知观察者
        
        缺点
            不灵活
            耦合性太高


### 适合场景
    当对象改变时需要改变其他对象

## 命令模式

### 描述
    命令模式是一种行为设计模式，
    它可以将请求转换为一个包含与请求相关的所有信息的独立对象，
    转换之后就能将根据不同的请求将方法参数化、延迟请求执行，
    或者放入队列且可实现撤销操作

### 示例场景

    我去宠物店给宠物打针，我会发出指令打针，
    接受者可以是前台也可以医生，如果是前台接收，他会转发给医生，
    让医生来处理，前台虽然不会执行指令，但是他知道谁能处理指令

### 命令模式常见的作用
    
    可以撤销
    可以放入命令队列
    利用宏命令进行批量执行

### 适用场景
    通过操作参数化对象
    将操作放入队列执行操作
    实现操作的回滚

### 优点
    可以撤销
    可以延迟执行
    命令对象一旦发送，生命周期就是永久的，除非被执行或撤销
    
### 缺点
    会增加代码的复杂度



## 组合模式

### 描述
    组合模式是一种结构性设计模式，可以使用它将对象组合成树状结构，
    并且能像使用独立对象的方式使用它们


### 适用场景
    
    表示对象的部分-整体层次结构，尤其是不确定有多少层，只需请求对顶层对象，
    就能实现统一操作

    希望统以相同方式处理简单和复杂的元素

### 注意
    组合模式不是父子关系，是一种HAS-A(聚合)关系

### 钩子方法hook
    底层组件提供钩子，但是钩子的使用由高层组件决定


## 享元模式

### 意图
    享元模式是一种结构性设计模式，它摒弃在每个对象中保存所有数据的方式，
    通过共享多个对象所共有的相同状态，可以在有限的内存中载入更多的对象



### 内部对象与外部对象
    享元模式要求把对象的属性划分为内部状态和外部状态

    内部状态
        内部状态存储于对象内部
        内部状态可以被一些对象共享
        内部状态独立于具体的场景，一般不会改变

    外部状态
        外部状态取决于场景，根据场景而变化，不能被共享
    

### 适用场景

    一个程序中使用了大量的相似对象
    大量对象的使用造成比较严重的内存开销
    对象的大多数状态都可以变为外部状态
    剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象


## 职责链

### 意图
    使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，
    将这些对象连成一条链，并沿这条链传递该请求，直到有一个对象处理他它为止

### 适用场景
    使用不同方式处理不同种类请求，而且顺序未知
    必须按顺序执行多个处理者
    所需处理者及顺序必须在运行时改变

### 优点
    控制请求处理顺序
    解耦请求者与接收者的复杂关系


## 中介者模式

### 意图
    中介者模式是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系，
    该模式会限制对象之间的直接交互，迫使他们通过一个中介者对象进行合作

### 适用场景
    一些对象与其他对象耦合度较高难以修改
    因为依赖其他组件而导致无法复用

### 好处
    减轻各个组件之间的耦合

    增加了组件的可复用性

### 坏处
    中介者对象是相对维护的
    时间长了之后，中介者可能会演化成上帝对象



## 装饰者模式

### 意图
    装饰模式是一种结构型设计模式，
    允许你通过将对象放入包含行为的特殊封装对象来为原对象绑定新的行为

### 适用场景
    希望不修改代码的情况下就能使用，并且希望在运行中为对象增加行为

### 好处
    无需新增子类就可以扩展对象的行为

    可以动态的添加或删除对象的功能

    可以使用多个装饰封装对象来组合几种行为

### 坏处
    实现行为不受装饰器顺序影响比较困难

## 状态模式

### 意图
    状态模式是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，
    使其看上去就像改变了自身所属的类一样

### 适用场景
    对象需要根据自身当前状态进行不同行为，同时状态非常多，与状态相关的行为频繁变更

    某个类需要根据成员属性更改行为，从而使用大量的条件语句


### 好处
    单一职责原则，将特定状态相关的代码放到单独的类中

    开闭原则，无需修改已有的状态类和上下文就能引入新状态

    消除臃肿的状态机条件语句简化上下文代码


## 适配器模式
    
### 意图
    适配器模式是一种结构设计模式，它能使接口不兼容的对象能够相互合作

### 好处
    单一职责原则，可以将接口或数据装换代码从程序主要业务逻辑中分离

    开闭原则，可以在不修改客户端代码的情况下在程序中添加新类型的适配器

