# JS代码执行过程

## 当想起JS代码执行过程时脑子里蹦出的几个关键字

    this、闭包、词法作用域、词法环境、变量环境、执行上下文、环境记录

    接着从代码编译开始慢慢了解，理清这几个关键字的关系

<br/>

## 解释器与编译器

    我们写出的js代码只能给开发者阅读，机器并不能理解，所以我们需要一个
    工具将我们的代码转化成机器可以理解的语言，这个工具有两种类型：解释
    器和编译器

    编译器会将一种语言转成一个二进制文件，也就是将文件转成另外一种机器
    可以理解的语言文件，这个产生的文件可以在机器上直接运行，所以只需编
    译一次就能多次执行，但是同一个文件不同机器不是都能运行的

    解释器并不会产生新的文件它会动态的进行解释和执行，每次执行都会重新
    解释和执行，js使用的就是解释器

    解释器会先对js代码进行词法分析、语法分析，在生成抽象语法树，然后进
    行代码的优化，最后生成机器能够理解的代码

    在词法分析阶段js代码会被拆解成token，然后在语法分析阶段将token组装
    成抽象语法树，如果有语法错误就会在这个阶段抛出，生成的抽象语法树已
    经确定了作用域的范围，抽象语法树的生成会需要ECMAScript的规范

<br/>

## 执行代码

    v8引擎会将AST生成字节码，因为字节码占用的内存比机器码小很多，
    执行时，会将字节码转成机器码，在执行过程中出现重复执行的代
    码，会被识别为热点代码，然后将热点代码编译成高效的机器码保存
    起来，提供下次的使用

<br/>

## 执行上下文

    执行上下文就是当前代码执行时的环境，有词法环境，变量环境，outer，
    this组成，执行上下文有多个， 执行上下文放在执行栈内

<br/>

## 词法环境和变量环境

    词法环境(LexicalEnvironment)与变量环境(VariableEnvironment)的区
    别在于通过不同的声明语法而创建,其实都是词法环境(Lexical
     Environment)

<br/>

## 全局环境

    代码开始执行首先会创建一个全局执行上下文，它的outer为null，它是
    Global的唯一实例，它有一个[[VarNames]]的内部结构，用来表明声明过的
    变量名与函数名，使用var声明的变量会加入[[VarNames]]列表，未使用var
    声明的不会加入到[[VarNames]]列表，使用const/let声明的变量，会直接
    创建在词法作用域内，与global对象无关

<br/>

## 模块环境

    当代码执行具体加载一个模块时模块环境会实例化，模块的实例化是使用深
    度遍历的，也就是叶子节点先完成实例化，这也意味着，子模块不能访问到
    父模块的变量

    全局环境的比模块环境先建立，但是它的执行代码晚于整个模块环境的实例
    化，这也表示模块的实例化不能依赖任何用户创建的全局变量

    模块环境同样是有变量环境和词法环境的，模块中代码时执行在严格模式中

<br/>


## 函数环境

    当函数开始执行时，会创建一个执行环境，然后会初始化闭包，在初始化的
    时候，JavaScript会将varDecls和lexicallyDecls两组信息合并成一份可
    访问的标识符列表，
    这个标识符列表由变量环境和词法环境组成，在严格模式下有所不同，如果
    是非严格模式，这两个部分引自同一个结构，但是在严格模式中，词法环境
    指向变量环境，这样就会形成词法环境能访变量环境但是变量环境不能访问
    词法环境的结果

    this是第一个可变的标识符，也是添加到闭包的第一个信息

    


    